{
  "constants": {
    "ACRONYCHAL_RISING": 5,
    "ACRONYCHAL_SETTING": 6,
    "ADMETOS": 45,
    "APOLLON": 44,
    "APP_TO_TRUE": 1,
    "ARMC": 2,
    "ASC": 0,
    "AST_OFFSET": 10000,
    "BIT_ASTRO_TWILIGHT": 4096,
    "BIT_CIVIL_TWILIGHT": 1024,
    "BIT_DISC_BOTTOM": 8192,
    "BIT_DISC_CENTER": 256,
    "BIT_FIXED_DISC_SIZE": 16384,
    "BIT_FORCE_SLOW_METHOD": 32768,
    "BIT_HINDU_RISING": 896,
    "BIT_NAUTIC_TWILIGHT": 2048,
    "BIT_NO_REFRACTION": 512,
    "CALC_ITRANSIT": 8,
    "CALC_MTRANSIT": 4,
    "CALC_RISE": 1,
    "CALC_SET": 2,
    "CERES": 17,
    "CHIRON": 15,
    "COASC1": 5,
    "COASC2": 6,
    "COMET_OFFSET": 1000,
    "COSMICAL_SETTING": 6,
    "CUPIDO": 40,
    "DE_NUMBER": 431,
    "EARTH": 14,
    "ECL2HOR": 0,
    "ECL_1ST_VISIBLE": 512,
    "ECL_2ND_VISIBLE": 1024,
    "ECL_3RD_VISIBLE": 2048,
    "ECL_4TH_VISIBLE": 4096,
    "ECL_ALLTYPES_LUNAR": 84,
    "ECL_ALLTYPES_SOLAR": 63,
    "ECL_ANNULAR": 8,
    "ECL_ANNULAR_TOTAL": 32,
    "ECL_CENTRAL": 1,
    "ECL_HYBRID": 32,
    "ECL_MAX_VISIBLE": 256,
    "ECL_NONCENTRAL": 2,
    "ECL_NUT": -1,
    "ECL_OCC_BEG_DAYLIGHT": 8192,
    "ECL_OCC_END_DAYLIGHT": 16384,
    "ECL_ONE_TRY": 32768,
    "ECL_PARTBEG_VISIBLE": 512,
    "ECL_PARTEND_VISIBLE": 4096,
    "ECL_PARTIAL": 16,
    "ECL_PENUMBBEG_VISIBLE": 8192,
    "ECL_PENUMBEND_VISIBLE": 16384,
    "ECL_PENUMBRAL": 64,
    "ECL_TOTAL": 4,
    "ECL_TOTBEG_VISIBLE": 1024,
    "ECL_TOTEND_VISIBLE": 2048,
    "ECL_VISIBLE": 128,
    "EQU2HOR": 1,
    "EQUASC": 4,
    "EVENING_FIRST": 3,
    "EVENING_LAST": 2,
    "FICT_MAX": 999,
    "FICT_OFFSET": 40,
    "FICT_OFFSET_1": 39,
    "FIXSTAR": -10,
    "FLG_ASTROMETRIC": 1536,
    "FLG_BARYCTR": 16384,
    "FLG_CENTER_BODY": 1048576,
    "FLG_DEFAULTEPH": 2,
    "FLG_DPSIDEPS_1980": 262144,
    "FLG_EQUATORIAL": 2048,
    "FLG_HELCTR": 8,
    "FLG_ICRS": 131072,
    "FLG_J2000": 32,
    "FLG_JPLEPH": 1,
    "FLG_JPLHOR": 262144,
    "FLG_JPLHOR_APPROX": 524288,
    "FLG_MOSEPH": 4,
    "FLG_NOABERR": 1024,
    "FLG_NOGDEFL": 512,
    "FLG_NONUT": 64,
    "FLG_ORBEL_AA": 32768,
    "FLG_RADIANS": 8192,
    "FLG_SIDEREAL": 65536,
    "FLG_SPEED": 256,
    "FLG_SPEED3": 128,
    "FLG_SWIEPH": 2,
    "FLG_TEST_PLMOON": 2228280,
    "FLG_TOPOCTR": 32768,
    "FLG_TROPICAL": 0,
    "FLG_TRUEPOS": 16,
    "FLG_XYZ": 4096,
    "GREG_CAL": 1,
    "HADES": 41,
    "HARRINGTON": 50,
    "HELFLAG_AV": 65536,
    "HELFLAG_AVKIND": 983040,
    "HELFLAG_AVKIND_MIN7": 262144,
    "HELFLAG_AVKIND_MIN9": 524288,
    "HELFLAG_AVKIND_PTO": 131072,
    "HELFLAG_AVKIND_VR": 65536,
    "HELFLAG_HIGH_PRECISION": 256,
    "HELFLAG_LONG_SEARCH": 128,
    "HELFLAG_NO_DETAILS": 1024,
    "HELFLAG_OPTICAL_PARAMS": 512,
    "HELFLAG_SEARCH_1_PERIOD": 2048,
    "HELFLAG_VISLIM_DARK": 4096,
    "HELFLAG_VISLIM_NOMOON": 8192,
    "HELFLAG_VISLIM_PHOTOPIC": 16384,
    "HELIACAL_RISING": 1,
    "HELIACAL_SETTING": 2,
    "HOR2ECL": 0,
    "HOR2EQU": 1,
    "INTP_APOG": 21,
    "INTP_PERG": 22,
    "ISIS": 48,
    "JUL_CAL": 0,
    "JUNO": 19,
    "JUPITER": 5,
    "KRONOS": 43,
    "MARS": 4,
    "MAX_STNAME": 256,
    "MC": 1,
    "MEAN_APOG": 12,
    "MEAN_NODE": 10,
    "MERCURY": 2,
    "MIXEDOPIC_FLAG": 2,
    "MODEL_BIAS": 4,
    "MODEL_DELTAT": 0,
    "MODEL_JPLHORA_MODE": 6,
    "MODEL_JPLHOR_MODE": 5,
    "MODEL_NUT": 3,
    "MODEL_PREC_LONGTERM": 1,
    "MODEL_PREC_SHORTTERM": 2,
    "MODEL_SIDT": 7,
    "MOD_BIAS_DEFAULT": 3,
    "MOD_BIAS_IAU2000": 2,
    "MOD_BIAS_IAU2006": 3,
    "MOD_BIAS_NONE": 1,
    "MOD_DELTAT_DEFAULT": 5,
    "MOD_DELTAT_ESPENAK_MEEUS_2006": 4,
    "MOD_DELTAT_STEPHENSON_1997": 2,
    "MOD_DELTAT_STEPHENSON_ETC_2016": 5,
    "MOD_DELTAT_STEPHENSON_MORRISON_1984": 1,
    "MOD_DELTAT_STEPHENSON_MORRISON_2004": 3,
    "MOD_JPLHORA_1": 1,
    "MOD_JPLHORA_2": 2,
    "MOD_JPLHORA_3": 3,
    "MOD_JPLHORA_DEFAULT": 3,
    "MOD_JPLHOR_DEFAULT": 1,
    "MOD_JPLHOR_LONG_AGREEMENT": 1,
    "MOD_NBIAS": 3,
    "MOD_NDELTAT": 5,
    "MOD_NJPLHOR": 2,
    "MOD_NJPLHORA": 3,
    "MOD_NNUT": 5,
    "MOD_NPREC": 11,
    "MOD_NUT_DEFAULT": 4,
    "MOD_NUT_IAU_1980": 1,
    "MOD_NUT_IAU_2000A": 3,
    "MOD_NUT_IAU_2000B": 4,
    "MOD_NUT_IAU_CORR_1987": 2,
    "MOD_NUT_WOOLARD": 5,
    "MOD_PREC_BRETAGNON_2003": 7,
    "MOD_PREC_DEFAULT": 9,
    "MOD_PREC_DEFAULT_SHORT": 9,
    "MOD_PREC_IAU_1976": 1,
    "MOD_PREC_IAU_2000": 6,
    "MOD_PREC_IAU_2006": 8,
    "MOD_PREC_LASKAR_1986": 2,
    "MOD_PREC_NEWCOMB": 11,
    "MOD_PREC_OWEN_1990": 10,
    "MOD_PREC_SIMON_1994": 5,
    "MOD_PREC_VONDRAK_2011": 9,
    "MOD_PREC_WILLIAMS_1994": 4,
    "MOD_PREC_WILL_EPS_LASK": 3,
    "MOON": 1,
    "MORNING_FIRST": 1,
    "MORNING_LAST": 4,
    "NALL_NAT_POINTS": 38,
    "NASCMC": 8,
    "NEPTUNE": 8,
    "NEPTUNE_ADAMS": 52,
    "NEPTUNE_LEVERRIER": 51,
    "NFICT_ELEM": 15,
    "NIBIRU": 49,
    "NODBIT_FOPOINT": 256,
    "NODBIT_MEAN": 1,
    "NODBIT_OSCU": 2,
    "NODBIT_OSCU_BAR": 4,
    "NPLANETS": 23,
    "NSE_MODELS": 8,
    "NSIDM_PREDEF": 47,
    "OSCU_APOG": 13,
    "PALLAS": 18,
    "PHOLUS": 16,
    "PHOTOPIC_FLAG": 0,
    "PLMOON_OFFSET": 9000,
    "PLUTO": 9,
    "PLUTO_LOWELL": 53,
    "PLUTO_PICKERING": 54,
    "POLASC": 7,
    "POSEIDON": 47,
    "PROSERPINA": 57,
    "SATURN": 6,
    "SCOTOPIC_FLAG": 1,
    "SIDBITS": 256,
    "SIDBIT_ECL_DATE": 2048,
    "SIDBIT_ECL_T0": 256,
    "SIDBIT_NO_PREC_OFFSET": 4096,
    "SIDBIT_PREC_ORIG": 8192,
    "SIDBIT_SSY_PLANE": 512,
    "SIDBIT_USER_UT": 1024,
    "SIDM_ALDEBARAN_15TAU": 14,
    "SIDM_ARYABHATA": 23,
    "SIDM_ARYABHATA_522": 37,
    "SIDM_ARYABHATA_MSUN": 24,
    "SIDM_B1950": 20,
    "SIDM_BABYL_BRITTON": 38,
    "SIDM_BABYL_ETPSC": 13,
    "SIDM_BABYL_HUBER": 12,
    "SIDM_BABYL_KUGLER1": 9,
    "SIDM_BABYL_KUGLER2": 10,
    "SIDM_BABYL_KUGLER3": 11,
    "SIDM_DELUCE": 2,
    "SIDM_DJWHAL_KHUL": 6,
    "SIDM_FAGAN_BRADLEY": 0,
    "SIDM_GALALIGN_MARDYKS": 34,
    "SIDM_GALCENT_0SAG": 17,
    "SIDM_GALCENT_COCHRANE": 40,
    "SIDM_GALCENT_MULA_WILHELM": 36,
    "SIDM_GALCENT_RGILBRAND": 30,
    "SIDM_GALEQU_FIORENZA": 41,
    "SIDM_GALEQU_IAU1958": 31,
    "SIDM_GALEQU_MULA": 33,
    "SIDM_GALEQU_TRUE": 32,
    "SIDM_HIPPARCHOS": 15,
    "SIDM_J1900": 19,
    "SIDM_J2000": 18,
    "SIDM_JN_BHASIN": 8,
    "SIDM_KRISHNAMURTI": 5,
    "SIDM_KRISHNAMURTI_VP291": 45,
    "SIDM_LAHIRI": 1,
    "SIDM_LAHIRI_1940": 43,
    "SIDM_LAHIRI_ICRC": 46,
    "SIDM_LAHIRI_VP285": 44,
    "SIDM_RAMAN": 3,
    "SIDM_SASSANIAN": 16,
    "SIDM_SS_CITRA": 26,
    "SIDM_SS_REVATI": 25,
    "SIDM_SURYASIDDHANTA": 21,
    "SIDM_SURYASIDDHANTA_MSUN": 22,
    "SIDM_TRUE_CITRA": 27,
    "SIDM_TRUE_MULA": 35,
    "SIDM_TRUE_PUSHYA": 29,
    "SIDM_TRUE_REVATI": 28,
    "SIDM_TRUE_SHEORAN": 39,
    "SIDM_USER": 255,
    "SIDM_USHASHASHI": 4,
    "SIDM_VALENS_MOON": 42,
    "SIDM_YUKTESHWAR": 7,
    "SIMULATE_VICTORVB": 1,
    "SPLIT_DEG_KEEP_DEG": 32,
    "SPLIT_DEG_KEEP_SIGN": 16,
    "SPLIT_DEG_NAKSHATRA": 1024,
    "SPLIT_DEG_ROUND_DEG": 4,
    "SPLIT_DEG_ROUND_MIN": 2,
    "SPLIT_DEG_ROUND_SEC": 1,
    "SPLIT_DEG_ZODIACAL": 8,
    "SUN": 0,
    "TIDAL_AUTOMATIC": 999999,
    "TRUE_NODE": 11,
    "TRUE_TO_APP": 0,
    "URANUS": 7,
    "VARUNA": 30000,
    "VENUS": 3,
    "VERTEX": 3,
    "VESTA": 20,
    "VULCAN": 55,
    "VULKANUS": 46,
    "WALDEMATH": 58,
    "WHITE_MOON": 56,
    "ZEUS": 42
  },
  "functions": {
    "Error": {
      "name": "Error",
      "doc": "No documentation available.",
      "full_doc": "No documentation available."
    },
    "azalt": {
      "name": "azalt",
      "doc": "Calculate horizontal coordinates (azimuth and altitude) of a planet or a star from either ecliptical or equatorial coordinates.",
      "full_doc": "Calculate horizontal coordinates (azimuth and altitude) of a planet or a star from either ecliptical or equatorial coordinates.\n\n:Args: float tjdut, int flag, seq geopos, float atpress, float attemp, seq xin\n\n - tjdut: input time, Julian day number, Universal Time\n - flag: either ECL2HOR (from ecliptical coord) or EQU2HOR (equatorial)\n - geopos: a sequence with:\n    - 0: geographic longitude, in degrees (eastern positive)\n    - 1: geographic latitude, in degrees (northern positive)\n    - 2: geographic altitude, in meters above sea level\n - atpress: atmospheric pressure in mbar (hPa)\n - attemp: atmospheric temperature in degrees Celsius\n - xin: a sequence with:\n    - ECL2HOR: ecl. longitude, ecl. latitude, distance\n    - EQU2HOR: right ascension, declination, distance\n\n:Return: float azimuth, true_altitude, apparent_altitude\n\n - azimuth: position degree, measured from south point to west\n - true_altitude: true altitude above horizon in degrees\n - apparent_altitude: apparent (refracted) altitude above horizon in   degrees\n\nThe apparent altitude of a body depends on the atmospheric pressure and temperature. If only the true altitude is required, these parameters can be neglected.\n\nIf ``atpress`` is given the value 0, the function estimates the pressure from the geographical altitude given in ``xin[3]`` and ``attemp``. If ``xin[3]`` is 0, ``atpress`` will be estimated for sea level."
    },
    "azalt_rev": {
      "name": "azalt_rev",
      "doc": "Calculate either ecliptical or equatorial coordinates from azimuth and true altitude.",
      "full_doc": "Calculate either ecliptical or equatorial coordinates from azimuth and true altitude.\n\n:Args: float tjdut, int flag, seq geopos, double azimuth, double true_altitude\n\n - tjdut: input time, Julian day number, Universal Time\n - flag: either HOR2ECL (to ecliptical coord) or HOR2EQU (to equatorial)\n - geopos: a sequence with:\n    - 0: geographic longitude, in degrees (eastern positive)\n    - 1: geographic latitude, in degrees (northern positive)\n    - 2: geographic altitude, in meters above sea level)\n - azimuth: position degree, measured from south point to west\n - true_altitude: true altitude above horizon in degrees\n\n:Return: float x1, x2\n\n - x1, x2: ecliptical or equatorial coordinates, depending on flag\n\nThis function is not precisely the reverse of ``azalt()``. It computes either ecliptical or equatorial coordinates from azimuth and true altitude. If only an apparent altitude is given, the true altitude has to be computed first with the function ``refrac()``."
    },
    "calc": {
      "name": "calc",
      "doc": "Calculate planetary positions (ET).",
      "full_doc": "Calculate planetary positions (ET).\n\n:Args: float tjdet, int planet, int flags=FLG_SWIEPH|FLG_SPEED\n\n - tjdet: Julian day, Ephemeris Time, where tjdet == tjdut + deltat(tjdut)\n - planet: body number\n - flags: bit flags indicating what kind of computation is wanted\n\n:Return: (xx), int retflags\n\n - xx: tuple of 6 float for results\n - retflags: bit flags indicating what kind of computation was done\n\nThis function can raise swisseph.Error in case of fatal error."
    },
    "calc_pctr": {
      "name": "calc_pctr",
      "doc": "Calculate planetocentric positions of planets (ET).",
      "full_doc": "Calculate planetocentric positions of planets (ET).\n\n:Args: float tjd, int planet, int center, int flags=FLG_SWIEPH|FLG_SPEED\n\n - tjdet: julian day in ET (TT)\n - planet: body number of target object\n - center: body number of center object\n - flags: bit flags indicating what kind of computation is wanted\n\n:Return: (xx), int retflags\n\n - xx: tuple of 6 float for results\n - retflags: bit flags indicating what kind of computation was done\n\nThis function can raise swisseph.Error in case of fatal error."
    },
    "calc_ut": {
      "name": "calc_ut",
      "doc": "Calculate planetary positions (UT).",
      "full_doc": "Calculate planetary positions (UT).\n\n:Args: float tjdut, int planet, int flags=FLG_SWIEPH|FLG_SPEED\n\n - tjdut: julian day number, universal time\n - planet: body number\n - flags: bit flags indicating what kind of computation is wanted\n\n:Return: (xx), int retflags\n\n - xx: tuple of 6 float for results\n - retflags: bit flags indicating what kind of computation was done\n\nThis function can raise swisseph.Error in case of fatal error."
    },
    "close": {
      "name": "close",
      "doc": "Close Swiss Ephemeris.",
      "full_doc": "Close Swiss Ephemeris.\n\n:Args: --\n:Return: None\n\nAt the end of your computations you can release all resources (open files and allocated memory) used by the swisseph module.\n\nAfter ``close()``, no swisseph functions should be used unless you call ``set_ephe_path()`` again and, if required, ``set_jpl_file()``."
    },
    "cotrans": {
      "name": "cotrans",
      "doc": "Coordinate transformation from ecliptic to equator or vice-versa.",
      "full_doc": "Coordinate transformation from ecliptic to equator or vice-versa.\n\n:Args: seq coord, float eps\n\n - coord: tuple of 3 float for coordinates:\n    - 0: longitude\n    - 1: latitude\n    - 2: distance (unchanged, can be set to 1)\n - eps: obliquity of ecliptic, in degrees\n\n:Return: float retlon, retlat, retdist\n\n - retlon: converted longitude\n - retlat: converted latitude\n - retdist: converted distance\n\nFor equatorial to ecliptical, obliquity must be positive. From ecliptical to equatorial, obliquity must be negative. Longitude, latitude and obliquity are in positive degrees."
    },
    "cotrans_sp": {
      "name": "cotrans_sp",
      "doc": "Coordinate transformation of position and speed, from ecliptic to equator or vice-versa.",
      "full_doc": "Coordinate transformation of position and speed, from ecliptic to equator or vice-versa.\n\n:Args: seq coord, float eps\n\n - coord: tuple of 6 float for coordinates:\n    - 0: longitude\n    - 1: latitude\n    - 2: distance\n    - 3: longitude speed\n    - 4: latitude speed\n    - 5: distance speed\n - eps: obliquity of ecliptic, in degrees\n\n:Return: float retlon, retlat, retdist, retlonsp, retlatsp, retdistsp\n\n - retlon, retlonsp: converted longitude and its speed\n - retlat, retlatsp: converted latitude and its speed\n - retdist, retdistsp: converted distance and its speed\n\nFor equatorial to ecliptical, obliquity must be positive. From ecliptical to equatorial, obliquity must be negative. Longitude, latitude, their speeds and obliquity are in positive degrees."
    },
    "cs2degstr": {
      "name": "cs2degstr",
      "doc": "Get degrees string from centiseconds.",
      "full_doc": "Get degrees string from centiseconds.\n\n:Args: int cs\n:Return: str retstr"
    },
    "cs2lonlatstr": {
      "name": "cs2lonlatstr",
      "doc": "Get longitude or latitude string from centiseconds.",
      "full_doc": "Get longitude or latitude string from centiseconds.\n\n:Args: int cs, bytes plus, bytes minus\n:Return: str retstr\n\nThis function raises TypeError if plus or minus parameter length is not exactly 1 byte."
    },
    "cs2timestr": {
      "name": "cs2timestr",
      "doc": "Get time string from centiseconds.",
      "full_doc": "Get time string from centiseconds.\n\n:Args: int cs, bytes sep, bool suppresszero=False\n:Return: str retstr\n\nThis function raises TypeError if sep parameter length is not exactly 1 byte."
    },
    "csnorm": {
      "name": "csnorm",
      "doc": "Normalization of any centisecond number to the range [0;360].",
      "full_doc": "Normalization of any centisecond number to the range [0;360].\n\n:Args: int cs\n:Return: int retcs"
    },
    "csroundsec": {
      "name": "csroundsec",
      "doc": "Round centiseconds, but at 29.5959 always down.",
      "full_doc": "Round centiseconds, but at 29.5959 always down.\n\n:Args: int cs\n:Return: int retcs"
    },
    "d2l": {
      "name": "d2l",
      "doc": "Double to integer with rounding, no overflow check.",
      "full_doc": "Double to integer with rounding, no overflow check.\n\n:Args: float d\n:Return: int i"
    },
    "date_conversion": {
      "name": "date_conversion",
      "doc": "Calculate Julian day number with check wether input date is correct.",
      "full_doc": "Calculate Julian day number with check wether input date is correct.\n\n:Args: int year, int month, int day, float hour=12.0, bytes cal=b'g'\n\n - year, month, day: input date\n - hour: input time, decimal with fraction\n - cal: calendar type, gregorian (b'g') or julian (b'j')\n\n:Return: bool isvalid, float jd, (dt)\n\n - isvalid: True if the input date and time are legal\n - jd: returned Julian day number\n - dt: a tuple for, if input was not valid, corrected year, month, day, hour;\n   if input was valid, contains input date and time\n\nThis function raises TypeError if cal length is not exactly 1 byte.\nIt raises ValueError if cal is not b'g' or b'j'."
    },
    "day_of_week": {
      "name": "day_of_week",
      "doc": "Calculate day of week number [0;6] from Julian day number (monday is 0).",
      "full_doc": "Calculate day of week number [0;6] from Julian day number (monday is 0).\n\n:Args: float jd\n:Return: int dow"
    },
    "deg_midp": {
      "name": "deg_midp",
      "doc": "Calculate midpoint (in degrees).",
      "full_doc": "Calculate midpoint (in degrees).\n\n:Args: float x1, float x2\n:Return: float midp"
    },
    "degnorm": {
      "name": "degnorm",
      "doc": "Normalization of any degree number to the range [0;360[.",
      "full_doc": "Normalization of any degree number to the range [0;360[.\n\n:Args: float x\n:Return: float xnorm"
    },
    "deltat": {
      "name": "deltat",
      "doc": "Calculate value of delta T from Julian day number.",
      "full_doc": "Calculate value of delta T from Julian day number.\n\n:Args: float tjdut\n\n- tjdut: input time, Julian day number, Universal Time\n\n:Return: float deltat\n\n - deltat: returned delta T value\n\nReminder::\n\n   tjdet == tjdut + deltat(tjdut)\n\nThis function is safe only if your application consistently uses the same ephemeris flags, if your application consistently uses the same ephemeris files, if you first call ``set_ephe_path()`` (with flag ``FLG_SWIEPH``) or ``set_jpl_file()`` (with flag ``FLG_JPLEPH``).\n\nAlso, it is safe if you first call ``set_tid_acc()`` with the tidal acceleration you want. However, do not use that function unless you know what you are doing.\n\nFor best control of the values returned, use function ``deltat_ex()`` instead.\n\nThe calculation of ephemerides in UT depends on Delta T, which depends on the ephemeris-inherent value of the tidal acceleration of the Moon. In default mode, the function ``deltat()`` automatically tries to find the required values.\n\nTwo warnings must be made, though:\n\n - It is not recommended to use a mix of old and new ephemeris files, because the old files were based on JPL Ephemeris DE406, whereas the new ones are based on DE431, and both ephemerides have a different inherent tidal acceleration of the Moon. A mixture of old and new ephemeris files may lead to inconsistent ephemeris output. Using old asteroid files ``se99999.se1`` together with new ones, can be tolerated, though.\n - The function ``deltat()`` uses a default value of tidal acceleration (that of DE431). However, after calling some older ephemeris, like Moshier ephemeris, DE200, or DE406, ``deltat()`` might provide slightly different values.\n\nIn case of troubles related to these two points, it is recommended to either use function ``deltat_ex()``, or control the value of the tidal acceleration using the functions ``set_tid_acc()`` and ``get_tid_acc()``."
    },
    "deltat_ex": {
      "name": "deltat_ex",
      "doc": "Calculate value of Delta T from Julian day number (extended).",
      "full_doc": "Calculate value of Delta T from Julian day number (extended).\n\n:Args: float tjdut, int flag\n\n - tjdut: input time, Julian day number, Universal Time\n - flag: ephemeris flag, ``FLG_SWIEPH`` ``FLG_JPLEPH`` ``FLG_MOSEPH``\n\n:Return: float deltat\n\n - deltat: returned delta T value\n\nCalling this function without a previous call of ``set_ephe_path()`` or  ``set_jpl_file()`` will raise swisseph.Error.\n\nThe calculation of ephemerides in UT depends on the ephemeris-inherent value of the tidal acceleration of the Moon. The function ``deltat_ex()`` can provide ephemeris-dependent values of Delta T and is therefore better than the old function ``deltat()``, which has to make un uncertain guess of what ephemeris is being used. One warning must be made, though:\n\nIt is not recommended to use a mix of old and new ephemeris files, because the old files were based on JPL Ephemeris DE406, whereas the new ones are based on DE431, and both ephemerides have a different inherent tidal acceleration of the Moon. A mixture of old and new ephemeris files may lead to inconsistent ephemeris output. Using old asteroid files ``se99999.se1`` together with new ones, can be tolerated, though."
    },
    "difcs2n": {
      "name": "difcs2n",
      "doc": "Calculate distance in centisecs p1 - p2 normalized to [-180;180].",
      "full_doc": "Calculate distance in centisecs p1 - p2 normalized to [-180;180].\n\n:Args: int p1, int p2\n:Return: int dist"
    },
    "difcsn": {
      "name": "difcsn",
      "doc": "Calculate distance in centisecs p1 - p2.",
      "full_doc": "Calculate distance in centisecs p1 - p2.\n\n:Args: int p1, int p2\n:Return: int dist"
    },
    "difdeg2n": {
      "name": "difdeg2n",
      "doc": "Calculate distance in degrees p1 - p2 normalized to [-180;180].",
      "full_doc": "Calculate distance in degrees p1 - p2 normalized to [-180;180].\n\n:Args: float p1, float p2\n:Return: float dist"
    },
    "difdegn": {
      "name": "difdegn",
      "doc": "Calculate distance in degrees p1 - p2.",
      "full_doc": "Calculate distance in degrees p1 - p2.\n\n:Args: float p1, float p2\n:Return: float dist"
    },
    "difrad2n": {
      "name": "difrad2n",
      "doc": "Calculate distance in radians p1 - p2 normalized to [-180;180].",
      "full_doc": "Calculate distance in radians p1 - p2 normalized to [-180;180].\n\n:Args: float p1, float p2\n:Return: float dist"
    },
    "fixstar": {
      "name": "fixstar",
      "doc": "Calculate fixed star positions (ET).",
      "full_doc": "Calculate fixed star positions (ET).\n\n:Args: str star, float tjdet, int flags=FLG_SWIEPH\n\n - star: name of fixed star to search for\n - tjdet: input time, Julian day number,  Ephemeris Time\n - flags: bit flags indicating what kind of computation is wanted\n\n:Return: (xx), str stnam, int retflags\n\n - xx: tuple of 6 float for results\n - stnam: returned star name\n - retflags: bit flags indicating what kind of computation was done\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "fixstar2": {
      "name": "fixstar2",
      "doc": "Calculate fixed star positions (faster version) (ET).",
      "full_doc": "Calculate fixed star positions (faster version) (ET).\n\n:Args: str star, float tjdet, int flags=FLG_SWIEPH\n\n - star: name of fixed star to search for\n - tjdet: input time, Julian day number, Ephemeris Time\n - flags: bit flags indicating what kind of computation is wanted\n\n:Return: (xx), str stnam, int retflags\n\n - xx: tuple of 6 float for results\n - stnam: returned star name\n - retflags: bit flags indicating what kind of computation was done\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "fixstar2_mag": {
      "name": "fixstar2_mag",
      "doc": "Get fixed star magnitude (faster version).",
      "full_doc": "Get fixed star magnitude (faster version).\n\n:Args: str star\n\n - star: name of fixed star\n\n:Return: float mag, str stnam\n\n - mag: returned magnitude\n - stnam: returned star name\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "fixstar2_ut": {
      "name": "fixstar2_ut",
      "doc": "Calculate fixed star positions (faster version) (UT).",
      "full_doc": "Calculate fixed star positions (faster version) (UT).\n\n:Args: str star, float tjdut, int flags=FLG_SWIEPH\n\n - star: name of fixed star to search for\n - tjdut: inputtime, Julian day nnumber, Universal Time\n - flags: bit flags indicating what kind of computation is wanted\n\n:Return: (xx), str stnam, int retflags\n\n - xx: tuple of 6 float for results\n - stnam: returned star name\n - retflags: bit flags indicating what kind of computation was done\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "fixstar_mag": {
      "name": "fixstar_mag",
      "doc": "Get fixed star magnitude.",
      "full_doc": "Get fixed star magnitude.\n\n:Args: str star\n\n - star: name of fixed star\n\n:Return: float mag, str stnam\n\n - mag: returned magnitude\n - stnam: returned star name\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "fixstar_ut": {
      "name": "fixstar_ut",
      "doc": "Calculate fixed star positions (UT).",
      "full_doc": "Calculate fixed star positions (UT).\n\n:Args: str star, float tjdut, int flags=FLG_SWIEPH\n\n - star: name of fixed star to search for\n - tjdut: input time, Julian day number,  Universal Time\n - flags: bit flags indicating what kind of computation is wanted\n\n:Return: (xx), str stnam, int retflags\n\n - xx: tuple of 6 float for results\n - stnam: returned star name\n - retflags: bit flags indicating what kind of computation was done\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "gauquelin_sector": {
      "name": "gauquelin_sector",
      "doc": "Calculate Gauquelin sector position of a body (UT).",
      "full_doc": "Calculate Gauquelin sector position of a body (UT).\n\n:Args: float tjdut, int or str body, int method, seq geopos, float atpress=0, float attemp=0, int flags=FLG_SWIEPH|FLG_TOPOCTR\n\n - tjdut: input time, Julian day number, Universal Time\n - body: planet number (int) or fixed star name (str)\n - method: number indicating which computation method is wanted:\n    - 0 with latitude\n    - 1 without latitude\n    - 2 from rising and setting times of the disc center of planet\n    - 3 from rising and setting times of disc center, incl. refraction\n    - 4 from rising and setting times of the disk edge of planet\n    - 5 from rising and setting times of disk edge, incl. refraction\n - geopos: a sequence containing:\n    - 0: geographic longitude, in degrees (eastern positive)\n    - 1: geographic latitude, in degrees (northern positive)\n    - 2: geographic altitude, in meters above sea level\n - atpress: atmospheric pressure (if 0, the default 1013.25 mbar is used)\n - attemp: atmospheric temperature in degrees Celsius\n - flags: bit flags for ephemeris and FLG_TOPOCTR, etc\n\n:Return: float sector\n\n - sector: [1;37[. Gauquelin sectors are numbered in clockwise direction.\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "get_ayanamsa": {
      "name": "get_ayanamsa",
      "doc": "Calculate ayanamsa (ET).",
      "full_doc": "Calculate ayanamsa (ET).\n\n:Args: float tjdet\n\n - tjdet: input time, Julian day number, Ephemeris Time\n\n:Return: float aya\n\n - aya: ayanamsa value, without nutation"
    },
    "get_ayanamsa_ex": {
      "name": "get_ayanamsa_ex",
      "doc": "Calculate ayanamsa, extended version (ET).",
      "full_doc": "Calculate ayanamsa, extended version (ET).\n\n:Args: float tjdet, int flags\n\n - tjdet: input time, Julian day number, Ephemeris Time\n - flags: ephemeris flag, etc\n\n:Return: int retflags, float aya\n\n - retflags: returned bit flags\n - aya: ayanamsa value\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "get_ayanamsa_ex_ut": {
      "name": "get_ayanamsa_ex_ut",
      "doc": "Calculate ayanamsa, extended version (UT).",
      "full_doc": "Calculate ayanamsa, extended version (UT).\n\n:Args: float tjdut, int flags\n\n - tjdut: input time, Julian day number, Universal Time\n - flags: ephemeris flag, etc\n\n:Return: int retflags, float aya\n\n - retflags: returned bit flags\n - aya: ayanamsa value\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "get_ayanamsa_name": {
      "name": "get_ayanamsa_name",
      "doc": "Get ayanamsa name from sidereal mode constant.",
      "full_doc": "Get ayanamsa name from sidereal mode constant.\n\n:Args: int sidmode\n:Return: str name\n\nIf sidmode is not found (incorrect), returned string is empty."
    },
    "get_ayanamsa_ut": {
      "name": "get_ayanamsa_ut",
      "doc": "Calculate ayanamsa (UT).",
      "full_doc": "Calculate ayanamsa (UT).\n\n:Args: float tjdut\n\n - tjdut: input time, Julian day number, Universal Time\n\n:Return: float aya\n\n - aya: ayanamsa value, without nutation"
    },
    "get_current_file_data": {
      "name": "get_current_file_data",
      "doc": "Find start and end date of an se1 ephemeris file after a function call.",
      "full_doc": "Find start and end date of an se1 ephemeris file after a function call.\n\n:Args: int fno\n\n - fno: an integer indicating what type of file is searched:\n    - 0: planet file sepl_xxx, used for Sun etc, or jpl file\n    - 1: moon file semo_xxx\n    - 2: main asteroid file seas_xxx, if such an object was computed\n    - 3: other asteroid or planetary moon file, if such object was computed\n    - 4: star file\n\n:Return: str path, float start, float end, int denum\n\n - path: full file path, or empty string if no data\n - start: start date of file\n - end: end date of file\n - denum: jpl ephemeris number 406 or 431 from which file was derived\n\nThis can be used to find out the start and end date of an ``se1`` ephemeris file after a call of ``calc()``.\n\nThe function returns data from internal file structures ``sweph.fidat`` used in the last call to ``calc()`` or ``fixstar()``. Data returned are (currently) 0 with JPL files and fixed star files. Thus, the function is only useful for ephemerides of planets or asteroids that are based on ``se1`` files."
    },
    "get_library_path": {
      "name": "get_library_path",
      "doc": "Find the path of the executable or swisseph library (dll) actually in use.",
      "full_doc": "Find the path of the executable or swisseph library (dll) actually in use.\n\n:Args: --\n:Return: str path\n\n.. note::\n\n    This function may fail on Windows, and only find the executable path, not the dll."
    },
    "get_orbital_elements": {
      "name": "get_orbital_elements",
      "doc": "Calculate osculating elements (Kepler elements) and orbital periods.",
      "full_doc": "Calculate osculating elements (Kepler elements) and orbital periods.\n\n:Args: float tjdet, int planet, int flags\n\n - tjdet: input time, Julian day number, Ephemeris Time (TT)\n - planet: identifier of planet or object\n - flags: bit flags indicating what computation is wanted:\n    - ephemeris flag: FLG_JPLEPH, FLG_SWIEPH, FLG_MOSEPH, etc\n    - center:\n       - Sun: FLG_HELCTR (assumed as default) or\n       - SS Barycentre: FLG_BARYCTR (rel. to solar system barycentre)\n         Only possible for planets beyond Jupiter.\n         For elements of the Moon, the calculation is geocentric.\n    - sum all masses inside the orbit to be computed (method of\n      Astronomical Almanac): FLG_ORBEL_AA\n    - reference ecliptic: FLG_J2000\n\n:Return: (elements)\n\n - elements: a tuple of 50 float, of which:\n    - 0: semimajor axis (a)\n    - 1: eccentricity (e)\n    - 2: inclination (in)\n    - 3: longitude of ascending node (upper-case omega OM)\n    - 4: argument of periapsis (lower-case omega om)\n    - 5: longitude of periapsis (peri)\n    - 6: mean anomaly at epoch (M0)\n    - 7: true anomaly at epoch (N0)\n    - 8: eccentric anomaly at epoch (E0)\n    - 9: mean longitude at epoch (LM)\n    - 10: sidereal orbital period in tropical years\n    - 11: mean daily motion\n    - 12: tropical period in years\n    - 13: synodic period in days, negative for inner planets or Moon\n    - 14: time of perihelion passage\n    - 15: perihelion distance\n    - 16: aphelion distance\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "get_planet_name": {
      "name": "get_planet_name",
      "doc": "Get a planet or asteroid name.",
      "full_doc": "Get a planet or asteroid name.\n\n:Args: int planet\n\n - planet: identifier of planet or object\n\n:Return: str name\n\n - name: name found or empty string\n\nIf an asteroid name is wanted, the function does the following:\n\nThe name is first looked for in the asteroid ephemeris file.\n\nBecause many asteroids, especially the ones with high catalogue numbers, have no names yet (or have only a preliminary designation like 1968 HB), and because the Minor Planet Center of the IAU add new names quite often, it happens that there is no name in the asteroid file although the asteroid has already been given a name.\n\nFor this, we have the file ``seasnam.txt``, a file that contains a list of all named asteroid and is usually more up to date. If ``calc()`` finds a preliminary designation, it looks for a name in this file.\n\nThe file ``seasnam.txt`` can be updated by the user. To do this, download the names list from the Minor Planet Center https://www.minorplanetcenter.net/iau/lists/MPNames.html, rename it as ``seasnam.txt`` and move it into your ephemeris directory.\n\nThe file ``seasnam.txt`` need not be ordered in any way. There must be one asteroid per line, first its catalogue number, then its name. The asteroid number may or may not be in brackets."
    },
    "get_tid_acc": {
      "name": "get_tid_acc",
      "doc": "Get current value of the tidal acceleration.",
      "full_doc": "Get current value of the tidal acceleration.\n\n:Args: --\n:Return: float tidacc"
    },
    "heliacal_pheno_ut": {
      "name": "heliacal_pheno_ut",
      "doc": "Provides data that are relevant for the calculation of heliacal risings and settings.",
      "full_doc": "Provides data that are relevant for the calculation of heliacal risings and settings.\n\n:Args: float tjdut, seq geopos, seq atmo, seq observer, str objname, int eventtype, int flags\n\n - tjdut: input time, Julian day number, Universal Time\n - geopos: a sequence with:\n    - 0: geographic longitude (eastern positive)\n    - 1: geographic latitude (northern positive)\n    - 2: altitude above sea level, in meters\n - atmo: a sequence with:\n    - 0: atmospheric pressure in mbar (hPa)\n    - 1: atmospheric temperature in degrees Celsius\n    - 2: relative humidity in %\n    - 3: if >= 1, Meteorological Range (km).\n      Between 1 and 0, total atmospheric coefficient (ktot).\n      If = 0, the other atmospheric parameters determine the total\n      atmospheric coefficient (ktot)\n - observer: a sequence with:\n    - 0: age of observer in years (default = 36)\n    - 1: snellen ratio of observers eyes (default = 1 = normal)\n    - The following parameters are only relevant if HELFLAG_OPTICAL_PARAMS\n      is set:\n    - 2: (0) = monocular, (1) = binocular (boolean)\n    - 3: telescope magnification, (0) = default to naked eye (binocular),\n      (1) = naked eye\n    - 4: optical aperture (telescope diameter) in mm\n    - 5: optical transmission\n - objname: name of planet or fixed star\n - eventtype: either:\n    - HELIACAL_RISING: morning first, for all visible planets and stars\n    - HELIACAL_SETTING: evening last, for all visible planets and stars\n    - EVENING_FIRST: evening first, for Mercury, Venus, Moon\n    - MORNING_LAST: morning last, for Mercury, Venus, Moon\n - flags: bit flags for ephemeris, and also:\n    - HELFLAG_OPTICAL_PARAMS: for optical instruments\n    - HELFLAG_NO_DETAILS: provide date, without details\n    - HELFLAG_VISLIM_DARK: behave as if Sun is at nadir\n    - HELFLAG_VISLIM_NOMOON: behave as if Moon is at nadir, i.e. the Moon as\n      a factor disturbing the observation is excluded, useful if one is not\n      interested in the heliacal date of that particular year, but in the\n      heliacal date of that epoch\n\n:Return: (dret)\n\n - dret: tuple of 50 float, of which:\n    - 0: AltO [deg] topocentric altitude of object (unrefracted)\n    - 1: AppAltO [deg] apparent altitude of object (refracted)\n    - 2: GeoAltO [deg] geocentric altitude of object\n    - 3: AziO [deg] azimuth of object\n    - 4: AltS [deg] topocentric altitude of Sun\n    - 5: AziS [deg] azimuth of Sun\n    - 6: TAVact [deg] actual topocentric arcus visionis\n    - 7: ARCVact [deg] actual (geocentric) arcus visionis\n    - 8: DAZact [deg] actual difference between object's and sun's azimuth\n    - 9: ARCLact [deg] actual longitude difference between object and sun\n    - 10: kact [-] extinction coefficient\n    - 11: minTAV [deg] smallest topocentric arcus visionis\n    - 12: TfistVR [JDN] first time object is visible, according to VR\n    - 13: TbVR [JDN] optimum time the object is visible, according to VR\n    - 14: TlastVR [JDN] last time object is visible, according to VR\n    - 15: TbYallop [JDN] best time the object is visible, according to Yallop\n    - 16: WMoon [deg] crescent width of Moon\n    - 17: qYal [-] q-test value of Yallop\n    - 18: qCrit [-] q-test criterion of Yallop\n    - 19: ParO [deg] parallax of object\n    - 20: Magn [-] magnitude of object\n    - 21: RiseO [JDN] rise/set time of object\n    - 22: RiseS [JDN] rise/set time of Sun\n    - 23: Lag [JDN] rise/set time of object minus rise/set time of Sun\n    - 24: TvisVR [JDN] visibility duration\n    - 25: LMoon [deg] crescent length of Moon\n    - 26: CVAact [deg]\n    - 27: Illum [%] new\n    - 28: CVAact [deg] new\n    - 29: MSk [-]\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "heliacal_ut": {
      "name": "heliacal_ut",
      "doc": "Find the Julian day of the next heliacal phenomenon.",
      "full_doc": "Find the Julian day of the next heliacal phenomenon.\n\n:Args: float tjdut, seq geopos, seq atmo, seq observer, str objname, int eventtype, int flags\n\n - tjdut: input time, Julian day number, Universal Time\n - geopos: a sequence with:\n    - 0: geographic longitude (eastern positive)\n    - 1: geographic latitude (northern positive)\n    - 2: altitude above sea level, in meters\n - atmo: a sequence with:\n    - 0: atmospheric pressure in mbar (hPa)\n    - 1: atmospheric temperature in degrees Celsius\n    - 2: relative humidity in %\n    - 3: if >= 1, Meteorological Range (km).\n      Between 1 and 0, total atmospheric coefficient (ktot).\n      If = 0, the other atmospheric parameters determine the total\n      atmospheric coefficient (ktot)\n - observer: a sequence with:\n    - 0: age of observer in years (default = 36)\n    - 1: snellen ratio of observers eyes (default = 1 = normal)\n    - The following parameters are only relevant if HELFLAG_OPTICAL_PARAMS\n      is set:\n    - 2: (0) = monocular, (1) = binocular (boolean)\n    - 3: telescope magnification, (0) = default to naked eye (binocular),\n      (1) = naked eye\n    - 4: optical aperture (telescope diameter) in mm\n    - 5: optical transmission\n - objname: name of planet or fixed star\n - eventtype: either:\n    - HELIACAL_RISING: morning first, for all visible planets and stars\n    - HELIACAL_SETTING: evening last, for all visible planets and stars\n    - EVENING_FIRST: evening first, for Mercury, Venus, Moon\n    - MORNING_LAST: morning last, for Mercury, Venus, Moon\n - flags: bit flags for ephemeris, and also:\n    - HELFLAG_OPTICAL_PARAMS: for optical instruments\n    - HELFLAG_NO_DETAILS: provide date, without details\n    - HELFLAG_VISLIM_DARK: behave as if Sun is at nadir\n    - HELFLAG_VISLIM_NOMOON: behave as if Moon is at nadir, i.e. the Moon as\n      a factor disturbing the observation is excluded, useful if one is not\n      interested in the heliacal date of that particular year, but in the\n      heliacal date of that epoch\n\n:Return: (dret)\n\n - dret: tuple of 3 Julian days:\n    - 0: start visibility\n    - 1: optimum visibility, 0 if flags >= HELFLAG_AV\n    - 2: end of visibility, 0 if flags >= HELFLAG_AV\n\nIt works between geographic latitudes 60s - 60n.\n\nDefault values for ``atmo``: If this is too much for you, set all these values to 0. The software will then set the following defaults: Pressure 1013.25, temperature 15, relative humidity 40. The values will be modified depending on the altitude of the observer above sea level. If the extinction coefficient (meteorological range) ``datm[3]`` is 0, the software will calculate its value from ``datm[0..2]``.\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "helio_cross": {
      "name": "helio_cross",
      "doc": "Compute a planet heliocentric crossing over some longitude (ET).",
      "full_doc": "Compute a planet heliocentric crossing over some longitude (ET).\n\n:Args: int planet, float x2cross, float tjdet, int flags=FLG_SWIEPH, bool backwards=False\n\n - planet: planet number\n - x2cross: longitude to search\n - tjdet: start time of search, as Julian day number, Ephemeris Time\n - flags: bit flags indicating what computation is wanted\n - backwards: a boolean indicating if we search back in time\n\n:Return: float jdcross\n\n - jdcross: Julian day found\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "helio_cross_ut": {
      "name": "helio_cross_ut",
      "doc": "Compute a planet heliocentric crossing over some longitude (UT).",
      "full_doc": "Compute a planet heliocentric crossing over some longitude (UT).\n\n:Args: int planet, float x2cross, float tjdut, int flags=FLG_SWIEPH, bool backwards=False\n\n - planet: planet number\n - x2cross: longitude to search\n - tjdut: start time of search, as Julian day number, Universal Time\n - flags: bit flags indicating what computation is wanted\n - backwards: a boolean indicating if we search back in time\n\n:Return: float jdcross\n\n - jdcross: Julian day found\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "house_name": {
      "name": "house_name",
      "doc": "Get the name of a house method.",
      "full_doc": "Get the name of a house method.\n\n:Args: bytes hsys\n\n - hsys: house system identifier (1 byte)\n\n:Return: str hsysname\n\n - hsysname: house system name, empty string if not found"
    },
    "house_pos": {
      "name": "house_pos",
      "doc": "Calculate house position of a body.",
      "full_doc": "Calculate house position of a body.\n\n:Args: float armc, float geolat, float eps, seq objcoord, bytes hsys=b'P'\n\n - armc: ARMC\n - geolat: geographic latitude, in degrees (northern positive)\n - eps: obliquity, in degrees\n - objcoord: a sequence for ecl. longitude and latitude of the planet,\n   in degrees\n - hsys: house method identifier (1 byte)\n\n:Return: float hpos\n\n - hpos: value in [1:13[ (Gauquelin: [1:37[) indicating the house position\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "houses": {
      "name": "houses",
      "doc": "Calculate houses cusps (UT).",
      "full_doc": "Calculate houses cusps (UT).\n\n:Args: float tjdut, float lat, float lon, bytes hsys=b'P'\n\n - tjdut: input time, Julian day number, Universal Time\n - lat: geographic latitude, in degrees (northern positive)\n - lon: geographic longitude, in degrees (eastern positive)\n - hsys: house method identifier (1 byte)\n\n:Return: (cusps), (ascmc)\n\n - cusps: tuple of 12 float for cusps (except Gauquelin: 36 float)\n - ascmc: tuple of 8 float for additional points\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "houses_armc": {
      "name": "houses_armc",
      "doc": "Calculate houses cusps with ARMC.",
      "full_doc": "Calculate houses cusps with ARMC.\n\n:Args: float armc, float lat, float eps, bytes hsys=b'P', float ascmc9=0.0\n\n - armc: ARMC\n - lat: geographic latitude, in degrees (northern positive)\n - eps: obliquity, in degrees\n - hsys: house method identifier (1 byte)\n - ascmc9: optional parameter for Sunshine house system\n\n:Return: (cusps), (ascmc)\n\n - cusps: tuple of 12 float for cusps (except Gauquelin: 36 float)\n - ascmc: tuple of 8 float for additional points\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "houses_armc_ex2": {
      "name": "houses_armc_ex2",
      "doc": "Calculate houses cusps and their speeds with ARMC.",
      "full_doc": "Calculate houses cusps and their speeds with ARMC.\n\n:Args: float armc, float lat, float eps, bytes hsys=b'P', float ascmc9=0.0\n\n - armc: ARMC\n - lat: geographic latitude, in degrees (northern positive)\n - eps: obliquity, in degrees\n - hsys: house method identifier (1 byte)\n - ascmc9: optional parameter for Sunshine house system\n\n:Return: (cusps), (ascmc), (cuspsspeed), (ascmcspeed)\n\n - cusps: tuple of 12 float for cusps (except Gauquelin: 36 float)\n - ascmc: tuple of 8 float for additional points\n - cuspsspeed: tuple of 12 float for cusps speeds\n - ascmcspeed: tuple of 8 float for speeds of additional points\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "houses_ex": {
      "name": "houses_ex",
      "doc": "Calculate houses cusps (extended) (UT).",
      "full_doc": "Calculate houses cusps (extended) (UT).\n\n:Args: float tjdut, float lat, float lon, bytes hsys=b'P', int flags=0\n\n - tjdut: input time, Julian day number, Universal Time\n - lat: geographic latitude, in degrees (northern positive)\n - lon: geographic longitude, in degrees (eastern positive)\n - hsys: house method identifier (1 byte)\n - flags: ephemeris flag, etc\n\n:Return: (cusps), (ascmc)\n\n - cusps: tuple of 12 float for cusps (except Gauquelin: 36 float)\n - ascmc: tuple of 8 float for additional points\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "houses_ex2": {
      "name": "houses_ex2",
      "doc": "Calculate houses cusps and cusps speeds (UT).",
      "full_doc": "Calculate houses cusps and cusps speeds (UT).\n\n:Args: float tjdut, float lat, float lon, bytes hsys=b'P', int flags=0\n\n - tjdut: input time, Julian day number, Universal Time\n - lat: geographic latitude, in degrees (northern positive)\n - lon: geographic longitude, in degrees (eastern positive)\n - hsys: house method identifier (1 byte)\n - flags: ephemeris flag, etc\n\n:Return: (cusps), (ascmc), (cuspsspeed), (ascmcspeed)\n\n - cusps: tuple of 12 float for cusps (except Gauquelin: 36 float)\n - ascmc: tuple of 8 float for additional points\n - cuspsspeed: tuple of 12 float for cusps speeds\n - ascmcspeed: tuple of 8 float for speeds of additional points\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "jdet_to_utc": {
      "name": "jdet_to_utc",
      "doc": "Convert ET Julian day number to UTC.",
      "full_doc": "Convert ET Julian day number to UTC.\n\n:Args: float tjdet, int cal=GREG_CAL\n\n - tjdet: Julian day number in ET (TT)\n - cal: calendar flag, either GREG_CAL or JUL_CAL\n\n:Return: int year, int month, int day, int hour, int mins, float secs\n\n - year, month, day: returned date\n - hour, mins, secs: returned time\n\nThis function raises ValueError if cal is not GREG_CAL or JUL_CAL."
    },
    "jdut1_to_utc": {
      "name": "jdut1_to_utc",
      "doc": "Convert UT1 Julian day number to UTC.",
      "full_doc": "Convert UT1 Julian day number to UTC.\n\n:Args: float tjdut, int cal=GREG_CAL\n\n - tjdut: Julian day number, in UT (UT1)\n - cal: either GREG_CAL or JUL_CAL\n\n:Return: int year, int month, int day, int hour, int mins, float secs\n\n - year, month, day: returned date\n - hour, mins, secs: returned time\n\nThis function raises ValueError if cal is not GREG_CAL or JUL_CAL."
    },
    "julday": {
      "name": "julday",
      "doc": "Calculate a Julian day number.",
      "full_doc": "Calculate a Julian day number.\n\n:Args: int year, int month, int day, float hour=12.0, int cal=GREG_CAL\n\n - year, month, day: the date\n - hour: the time of day, decimal with fraction\n - cal: either GREG_CAL (gregorian) or JUL_CAL (julian)\n\n:Return: float jd\n\nThis function raises ValueError if cal is not GREG_CAL or JUL_CAL."
    },
    "lat_to_lmt": {
      "name": "lat_to_lmt",
      "doc": "Translate local apparent time (LAT) to local mean time (LMT).",
      "full_doc": "Translate local apparent time (LAT) to local mean time (LMT).\n\n:Args: float tjdlat, float geolon\n\n - tjdlat: Julian day number, local apparent time\n - geolon: geographic longitude, in degrees (eastern positive)\n\n:Return: float tjdlmt\n\n - tjdlmt: returned Julian day number, local mean time\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "lmt_to_lat": {
      "name": "lmt_to_lat",
      "doc": "Translate local mean time (LMT) to local apparent time (LAT).",
      "full_doc": "Translate local mean time (LMT) to local apparent time (LAT).\n\n:Args: float tjdlmt, float geolon\n\n - tjdlmt: Julian day number, local mean time\n - geolon: geographic longitude, in degrees (eastern positive)\n\n:Return: float tjdlat\n\n - tjdlat: returned Julian day number, local apparent time\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "lun_eclipse_how": {
      "name": "lun_eclipse_how",
      "doc": "Calculate attributes of a lunar eclipse (UTC).",
      "full_doc": "Calculate attributes of a lunar eclipse (UTC).\n\n:Args: float tjdut, seq geopos, int flags=FLG_SWIEPH\n\n - tjdut: input time, Julian day number, Universal Time\n - geopos: a sequence with:\n    - geographic longitude, in degrees (eastern positive)\n    - geographic latitude, in degrees (northern positive)\n    - geographic altitude above sea level, in meters\n - flags: ephemeris flag, etc\n\n:Return: int retflag, (attr)\n\n - retflag: returned bit flags:\n    - 0 if there is no eclipse\n    - SE_ECL_TOTAL or ECL_PENUMBRAL or ECL_PARTIAL\n - attr: tuple of 20 float, of which:\n    - 0: umbral magnitude at tjd\n    - 1: penumbral magnitude\n    - 2: ?\n    - 3: ?\n    - 4: azimuth of moon at tjd\n    - 5: true altitude of moon above horizon at tjd\n    - 6: apparent altitude of moon above horizon at tjd\n    - 7: distance of moon from opposition in degrees\n    - 8: eclipse magnitude (equals attr[0])\n    - 9: saros series number (if available, otherwise -99999999)\n    - 10: saros series member number (if available, otherwise -99999999)\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "lun_eclipse_when": {
      "name": "lun_eclipse_when",
      "doc": "Find the next lunar eclipse globally (UT).",
      "full_doc": "Find the next lunar eclipse globally (UT).\n\n:Args: float tjdut, int flags=FLG_SWIEPH, int ecltype=0, bool backwards=False\n\n - tjdut: input time, Julian day number, Universal Time\n - flags: ephemeris flag\n - ecltype: bit flags for eclipse type wanted:\n    - ECL_TOTAL ECL_PARTIAL ECL_PENUMBRAL\n    - ECL_ALLTYPES_LUNAR or 0 for any type\n - backwards: boolean, set to True to search back in time\n\n:Return: int retflag, (tret)\n\n - retflag: returned bit flag:\n    - ECL_TOTAL ECL_PARTIAL ECL_PENUMBRAL\n - tret: tuple of 10 float, of which:\n    - 0: time of maximum eclipse\n    - 1: ?\n    - 2: time of partial phase begin (indices consistent with solar eclipses)\n    - 3: time of partial phase end\n    - 4: time of totality begin\n    - 5: time of totality end\n    - 6: time of penumbral phase begin\n    - 7: time of penumbral phase end\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "lun_eclipse_when_loc": {
      "name": "lun_eclipse_when_loc",
      "doc": "Find the next lunar eclipse observable from a given geographic position (UT).",
      "full_doc": "Find the next lunar eclipse observable from a given geographic position (UT).\n\n:Args: float tjdut, seq geopos, int flags=FLG_SWIEPH, bool backwards=False\n\n - tjdut: input time, Julian day number, Universal Time\n - geopos: a sequence with:\n    - geographic longitude, in degrees (eastern positive)\n    - geographic latitude, in degrees (northern positive)\n    - geographic altitude, in meters above sea level\n - flags: ephemeris flag, etc\n - backwards: boolean, set to True to search back in time\n\n:Return: int retflag, (tret), (attr)\n\n - retflag: returned bit flags:\n    - ECL_TOTAL or ECL_PENUMBRAL or ECL_PARTIAL\n - tret: tuple of 10 float, of which:\n    - 0: time of maximum eclipse\n    - 1: ?\n    - 2: time of partial phase begin (indices consistent with solar eclipses)\n    - 3: time of partial phase end\n    - 4: time of totality begin\n    - 5: time of totality end\n    - 6: time of penumbral phase begin (eclipse begin)\n    - 7: time of penumbral phase end (eclipse end)\n    - 8: time of moonrise, if it occurs during the eclipse\n    - 9: time of moonset, if it occurs during the eclipse\n - attr: tuple of 20 float, of which:\n    - 0: umbral magnitude at tjd\n    - 1: penumbral magnitude\n    - 2: ?\n    - 3: ?\n    - 4: azimuth of moon at tjd\n    - 5: true altitude of moon above horizon at tjd\n    - 6: apparent altitude of moon above horizon at tjd\n    - 7: distance of moon from opposition in degrees (separation angle)\n    - 8: umbral magnitude at tjd (equals attr[0])\n    - 9: saros series number (if available; otherwise -99999999)\n    - 10: saros series member number (if available; otherwise -99999999)\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "lun_occult_when_glob": {
      "name": "lun_occult_when_glob",
      "doc": "Find the next occultation of a planet or star by the moon globally (UT).",
      "full_doc": "Find the next occultation of a planet or star by the moon globally (UT).\n\n:Args: float tjdut, int or str body, int flags=FLG_SWIEPH, int ecltype=0, bool backwards=False\n\n - tjdut: input time, Julian day number, Universal Time\n - body: planet identifier (int) or star name (str)\n - flags: ephemeris flag, eventually ECL_ONE_TRY, etc\n - ecltype: bit flags for eclipse type wanted:\n    - ECL_CENTRAL ECL_NONCENTRAL ECL_TOTAL ECL_ANNULAR ECL_PARTIAL\n    - ECL_ANNULAR_TOTAL (equals ECL_HYBRID)\n    - 0 for any type\n - backwards: boolean, set to True to search back in time\n\n:Return: int retflags, (tret)\n\n - retflags: returned bit flags:\n    - 0 if no occultation or eclipse found\n    - ECL_TOTAL or ECL_ANNULAR or ECL_PARTIAL or ECL_ANNULAR_TOTAL    - ECL_CENTRAL\n    - ECL_NONCENTRAL\n - tret: tuple of 10 float, of which:\n    - 0: time of maximum occultation/eclipse\n    - 1: time when occultation takes place at local apparent noon\n    - 2: time of occultation begin\n    - 3: time of occultation end\n    - 4: time of of totality begin\n    - 5: time of totality end\n    - 6: time of center line begin\n    - 7: time of center line end\n    - 8: time when annular-total occultation becomes total\n    - 9: time when annular-total occultation becomes annular again\n\nThis function raises swisseph.Error in case of fatal error.\n\nIf you want to have only one conjunction of the moon with the body tested, add the following flag: ECL_ONE_TRY. If this flag is not set, the function will search for an occultation until it finds one. For bodies with ecliptical latitudes > 5, the function may search successlessly until it reaches the end of the ephemeris."
    },
    "lun_occult_when_loc": {
      "name": "lun_occult_when_loc",
      "doc": "Find next occultation of a planet or star by the moon for a given geographic position (UT).",
      "full_doc": "Find next occultation of a planet or star by the moon for a given geographic position (UT).\n\n:Args: float tjdut, int or str body, seq geopos, int flags=FLG_SWIEPH, bool backwards=False\n\n - tjdut: input time, Julian day number, Universal Time\n - body: planet identifier (int) or star name (str)\n - geopos: a sequence with:\n    - geographic longitude, in degrees (eastern positive)\n    - geographic latitude, in degrees (northern positive)\n    - geographic altitude above sea level, in meters\n - flags: ephemeris flag, eventually ECL_ONE_TRY, etc\n - backwards: boolean, set to True for search back in time\n\n:Return: int retflags, (tret), (attr)\n\n - retflags: returned bit flags:\n    - 0 if no occultation or eclipse found\n    - ECL_TOTAL or ECL_ANNULAR or ECL_PARTIAL,\n    - ECL_VISIBLE, ECL_MAX_VISIBLE, ECL_1ST_VISIBLE, ECL_2ND_VISIBLE,\n      ECL_3RD_VISIBLE, ECL_4TH_VISIBLE\n - tret: tuple of 10 float, of which:\n    - 0: time of maximum occultation\n    - 1: time of first contact\n    - 2: time of second contact\n    - 3: time of third contact\n    - 4: time of fourth contact\n - attr: tuple of 20 float, of which:\n    - 0: fraction of planet diameter covered by moon (magnitude)\n    - 1: ratio of lunar diameter to planet one\n    - 2: fraction of planet disc covered by moon (obscuration)\n    - 3: diameter of core shadow in km\n    - 4: azimuth of planet at tjd\n    - 5: true altitude of planet above horizon at tjd\n    - 6: apparent altitude of planet above horizon at tjd\n    - 7: elongation of moon in degrees (separation angle)\n\nThis function raises swisseph.Error in case of fatal error.\n\nIf you want to have only one conjunction of the moon with the body tested, add the following flag: ECL_ONE_TRY. If this flag is not set, the function will search for an occultation until it finds one. For bodies with ecliptical latitudes > 5, the function may search successlessly until it reaches the end of the ephemeris."
    },
    "lun_occult_where": {
      "name": "lun_occult_where",
      "doc": "Find where a lunar occultation is central or maximal (UT).",
      "full_doc": "Find where a lunar occultation is central or maximal (UT).\n\n:Args: float tjdut, int or str body, int flags=FLG_SWIEPH\n\n - tjdut: input time, Julian day number, Universal Time\n - body: planet identifier (int) or star name (str)\n - flags: ephemeris flag\n\n:Return: int retflags, (geopos), (attr)\n\n - retflags: returned bit flags:\n    - 0 if there is no occultation at tjd\n    - ECL_TOTAL\n    - ECL_ANNULAR\n    - ECL_TOTAL | ECL_CENTRAL\n    - ECL_TOTAL | ECL_NONCENTRAL\n    - ECL_ANNULAR | ECL_CENTRAL\n    - ECL_ANNULAR | ECL_NONCENTRAL\n    - ECL_PARTIAL\n - geopos: tuple of 10 float, of which:\n    - 0: geographic longitude of central line\n    - 1: geographic latitude of central line\n    - 2: geographic longitude of northern limit of umbra\n    - 3: geographic latitude of northern limit of umbra\n    - 4: geographic longitude of southern limit of umbra\n    - 5: geographic latitude of southern limit of umbra\n    - 6: geographic longitude of northern limit of penumbra\n    - 7: geographic latitude of northern limit of penumbra\n    - 8: geographic longitude of southern limit of penumbra\n    - 9: geographic latitude of southern limit of penumbra\n - attr: tuple of 20 float, of which:\n    - 0: fraction of object's diameter covered by moon (magnitude)\n    - 1: ratio of lunar diameter to object's diameter\n    - 2: fraction of object's disc covered by moon (obscuration)\n    - 3: diameter of core shadow in km\n    - 4: azimuth of object at tjd\n    - 5: true altitude of object above horizon at tjd\n    - 6: apparent altitude of object above horizon at tjd\n    - 7: angular distance of moon from object in degrees\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "mooncross": {
      "name": "mooncross",
      "doc": "Compute Moon crossing over some longitude (ET).",
      "full_doc": "Compute Moon crossing over some longitude (ET).\n\n:Args: float x2cross, float tjdet, int flags=FLG_SWIEPH\n\n - x2cross: longitude to search\n - tjdet: start time of search, Julian day number, Ephemeris Time\n - flags: bit flags indicating what computation is wanted\n\n:Return: float jd_cross\n\n - jd_cross: Julian day number found\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "mooncross_node": {
      "name": "mooncross_node",
      "doc": "Compute next Moon crossing over node, by finding zero latitude crossing (ET).",
      "full_doc": "Compute next Moon crossing over node, by finding zero latitude crossing (ET).\n\n:Args: float tjdet, int flags=FLG_SWIEPH\n\n - tjdet: start time of search, Julian day number, Ephemeris Time\n - flags: bit flags indicating what computation is wanted\n\n:Return: float jd_cross, xlon, xlat\n\n - jd_cross: Julian day number found\n - xlon: Moon longitude found\n - xlat: Moon latitude found\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "mooncross_node_ut": {
      "name": "mooncross_node_ut",
      "doc": "Compute next Moon crossing over node, by finding zero latitude crossing (UT).",
      "full_doc": "Compute next Moon crossing over node, by finding zero latitude crossing (UT).\n\n:Args: float tjdut, int flags=FLG_SWIEPH\n\n - tjdut: start time of search, Julian day number, Universal Time\n - flags: bit flags indicating what computation is wanted\n\n:Return: float jd_cross, xlon, xlat\n\n - jd_cross: Julian day number found\n - xlon: Moon longitude found\n - xlat: Moon latitude found\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "mooncross_ut": {
      "name": "mooncross_ut",
      "doc": "Compute Moon crossing over some longitude (UT).",
      "full_doc": "Compute Moon crossing over some longitude (UT).\n\n:Args: float x2cross, float tjdut, int flags=FLG_SWIEPH\n\n - x2cross: longitude to search\n - tjdut: start time of search, Julian day number, Universal Time\n - flags: bit flags indicating what computation is wanted\n\n:Return: float jd_cross\n\n - jd_cross: Julian day number found\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "nod_aps": {
      "name": "nod_aps",
      "doc": "Calculate planetary nodes and apsides (ET).",
      "full_doc": "Calculate planetary nodes and apsides (ET).\n\n:Args: float tjdet, int planet, int method=NODBIT_MEAN, int flags=FLG_SWIEPH|FLG_SPEED\n\n - tjdet: input time, Julian day number, Ephemeris Time\n - planet: identifer of planet or object\n - method: bit flags NODBIT_MEAN, NODBIT_OSCU, NODBIT_OSCU_BAR, NODBIT_FOPOINT\n - flags: bit flags indicating what type of computation is wanted\n\n:Return: (xnasc)(xndsc)(xperi)(xaphe)\n\n - xnasc: tuple of 6 float for ascending node\n - xndsc: tuple of 6 float for descending node\n - xperi: tuple of 6 float for perihelion\n - xaphe: tuple of 6 float for aphelion\n\nThis function can raise swisseph.Error in case of fatal error."
    },
    "nod_aps_ut": {
      "name": "nod_aps_ut",
      "doc": "Calculate planetary nodes and apsides (UT).",
      "full_doc": "Calculate planetary nodes and apsides (UT).\n\n:Args: float tjdut, int planet, int method=NODBIT_MEAN, int flags=FLG_SWIEPH|FLG_SPEED\n\n - tjdut: input time, Julian day number, Universal Time\n - planet: identifer of planet or object\n - method: bit flags NODBIT_MEAN, NODBIT_OSCU, NODBIT_OSCU_BAR, NODBIT_FOPOINT\n - flags: bit flags indicating what type of computation is wanted\n\n:Return: (xnasc)(xndsc)(xperi)(xaphe)\n\n - xnasc: tuple of 6 float for ascending node\n - xndsc: tuple of 6 float for descending node\n - xperi: tuple of 6 float for perihelion\n - xaphe: tuple of 6 float for aphelion\n\nThis function can raise swisseph.Error in case of fatal error."
    },
    "orbit_max_min_true_distance": {
      "name": "orbit_max_min_true_distance",
      "doc": "Calculate the maximum possible distance, the minimum possible distance, and the current true distance of planet, the EMB, or an asteroid.",
      "full_doc": "Calculate the maximum possible distance, the minimum possible distance, and the current true distance of planet, the EMB, or an asteroid.\n\n:Args: float tjdet, int planet, int flags\n\n - tjdet: input time, Julian day number, Ephemeris Time\n - planet: identifier of planet or object\n - flags: bit flags indicating what computation is wanted:\n    - ephemeris flag\n    - optional heliocentric flag FLG_HELIOCTR\n\n:Return: float max_dist, float min_dist, float true_dist\n\n - max_dist: maximum distance\n - min_dist: minimum_distance\n - true_dist: true distance"
    },
    "pheno": {
      "name": "pheno",
      "doc": "Calculate planetary phenomena (ET).",
      "full_doc": "Calculate planetary phenomena (ET).\n\n:Args: float tjdet, int planet, int flags=FLG_SWIEPH\n\n - tjdet: input time, Julian day number, Ephemeris Time\n - planet: object identifier\n - flags: ephemeris flag, etc\n\n:Return: (attr)\n\n - attr: tuple of 20 float, of which:\n    - 0: phase angle (earth-planet-sun)\n    - 1: phase (illuminated fraction of disc)\n    - 2: elongation of planet\n    - 3: apparent diameter of disc\n    - 4: apparent magnitude\n    - 5: geocentric horizontal parallax (Moon)\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "pheno_ut": {
      "name": "pheno_ut",
      "doc": "Calculate planetary phenomena (UT).",
      "full_doc": "Calculate planetary phenomena (UT).\n\n:Args: float tjdut, int planet, int flags=FLG_SWIEPH\n\n - tjdut: input time, Julian day number, Universal Time\n - planet: object identifier\n - flags: ephemeris flag, etc\n\n:Return: (attr)\n\n - attr: tuple of 20 float, of which:\n    - 0: phase angle (earth-planet-sun)\n    - 1: phase (illuminated fraction of disc)\n    - 2: elongation of planet\n    - 3: apparent diameter of disc\n    - 4: apparent magnitude\n    - 5: geocentric horizontal parallax (Moon)\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "rad_midp": {
      "name": "rad_midp",
      "doc": "Calculate midpoint (in radians).",
      "full_doc": "Calculate midpoint (in radians).\n\nArgs: float x, float y\nReturn: float"
    },
    "radnorm": {
      "name": "radnorm",
      "doc": "Normalization of any radian number to the range [0;2*pi].",
      "full_doc": "Normalization of any radian number to the range [0;2*pi].\n\nArgs: float x\nReturn: float"
    },
    "refrac": {
      "name": "refrac",
      "doc": "Calculate true altitude from apparent altitude, or vice-versa.",
      "full_doc": "Calculate true altitude from apparent altitude, or vice-versa.\n\n:Args: float alt, float atpress, float attemp, int flag\n\n - alt: altitude of object above geometric horizon in degrees,\n   where geometric horizon = plane perpendicular to gravity\n - atpress: atmospheric pressure in mbar (hPa)\n - attemp: atmospheric temperature in degrees Celsius\n - flag: either TRUE_TO_APP or APP_TO_TRUE\n\n:Return: float retalt\n\n - retalt: converted altitude"
    },
    "refrac_extended": {
      "name": "refrac_extended",
      "doc": "Calculate true altitude from apparent altitude, or vice-versa (extended).",
      "full_doc": "Calculate true altitude from apparent altitude, or vice-versa (extended).\n\n:Args: float alt, float geoalt, float atpress, float attemp, float lapserate, int flag\n\n - alt: altitude of object above geometric horizon in degrees,\n   where geometric horizon = plane perpendicular to gravity\n - geoalt: altitude of observer above sea level, in meters\n - atpress: atmospheric pressure in mbar (hPa)\n - attemp: atmospheric temperature in degrees Celsius\n - lapserate: dattemp/dgeoalt [deg K/m]\n - flag: either TRUE_TO_APP or APP_TO_TRUE\n\n:Return: float retalt, (dret)\n\n - retalt: converted altitude\n - dret: tuple of 4 float:\n    - 0: true altitude if possible, otherwise input value\n    - 1: apparent altitude if possible, otherwise input value\n    - 2: refraction\n    - 3: dip of the horizon"
    },
    "revjul": {
      "name": "revjul",
      "doc": "Calculate year, month, day, hour from Julian day number.",
      "full_doc": "Calculate year, month, day, hour from Julian day number.\n\n:Args: float jd, int cal=GREG_CAL\n\n - jd: Julian day number\n - cal: either GREG_CAL (gregorian) or JUL_CAL (julian)\n\n:Return: int year, int month, int day, float hour\n\nThis function raises ValueError if cal is not GREG_CAL or JUL_CAL."
    },
    "rise_trans": {
      "name": "rise_trans",
      "doc": "Calculate times of rising, setting and meridian transits.",
      "full_doc": "Calculate times of rising, setting and meridian transits.\n\n:Args: float tjdut, int or str body, int rsmi, seq geopos, float atpress=0.0, float attemp=0.0, int flags=FLG_SWIEPH\n\n - tjdut: input time, Julian day number, Universal Time\n - body: planet identifier (int) or fixed star name (str)\n - rsmi: bit flag for rise, set, or one of the two meridian transits, etc\n - geopos: a sequence for:\n    - 0: geographic longitude, in degrees (eastern positive)\n    - 1: geographic latitude, in degrees (northern positive)\n    - 2: geographic altitude, in meters above sea level\n - atpress: atmospheric pressure in mbar/hPa\n - attemp: atmospheric temperature in degrees Celsius\n - flags: ephemeris flags etc\n\n:Return: int res, (tret)\n\n - res: integer indicating:\n    - (0) event found\n    - (-2) event not found because the object is circumpolar\n - tret: tuple of 10 float, of which:\n    - 0: tjd of event\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "rise_trans_true_hor": {
      "name": "rise_trans_true_hor",
      "doc": "Calculate times of rising, setting and meridian transits (with altitude).",
      "full_doc": "Calculate times of rising, setting and meridian transits (with altitude).\n\n:Args: float tjdut, int or str body, int rsmi, seq geopos, float atpress=0.0, float attemp=0.0, float horhgt=0.0, int flags=FLG_SWIEPH\n\n - tjdut: input time, Julian day number, Universal Time\n - body: planet identifier (int) or fixed star name (str)\n - rsmi: bit flag for rise, set, or one of the two meridian transits, etc\n - geopos: a sequence for:\n    - 0: geographic longitude (eastern positive)\n    - 1: geographic latitude (northern positive)\n    - 2: altitude above sea level, in meters\n - atpress: atmospheric pressure in mbar/hPa\n - attemp: atmospheric temperature in degrees Celsius\n - horhgt: height of local horizon in degrees (where body rises or sets)\n - flags: ephemeris flags etc\n\n:Return: int res, (tret)\n\n - res: integer indicating:\n    - 0 event found\n    - -2 event not found because the object is circumpolar\n - tret: tuple of 10 float, of which:\n    - 0: tjd of event\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "set_delta_t_userdef": {
      "name": "set_delta_t_userdef",
      "doc": "Set a fixed Deltat T value.",
      "full_doc": "Set a fixed Deltat T value.\n\n:Args: acc\n:Return: None\n\nThis function allows the user to set a fixed Delta T value that will be returned by ``deltat()`` or ``deltat_ex()``. The same Delta T value will then be used by ``calc_ut()``, eclipse functions, heliacal functions, and all functions that require UT as input time.\n\nIn order to return to automatic Delta T, call this function with the following value: ``set_delta_t_userdef(DELTAT_AUTOMATIC)``."
    },
    "set_ephe_path": {
      "name": "set_ephe_path",
      "doc": "Set ephemeris files path.",
      "full_doc": "Set ephemeris files path.\n\n:Args: str path=\"/usr/share/swisseph:/usr/local/share/swisseph\"\n:Return: None\n\nIt is possible to pass None as path, which is equivalent to an empty string."
    },
    "set_jpl_file": {
      "name": "set_jpl_file",
      "doc": "Set name of JPL ephemeris file.",
      "full_doc": "Set name of JPL ephemeris file.\n\n:Args: str name\n:Return: None\n\nIf you work with the JPL ephemeris, SwissEph uses the default file name which is defined as ``FNAME_DFT``. Currently, it has the value ``de406.eph`` or ``de431.eph``.\n\nIf a different JPL ephemeris file is required, call this function to make the file name known to the software, eg::\n\n    swe.set_jpl_file('de405.eph')\n\nThis file must reside in the ephemeris path you are using for all your ephemeris files."
    },
    "set_lapse_rate": {
      "name": "set_lapse_rate",
      "doc": "Set lapse rate.",
      "full_doc": "Set lapse rate.\n\n:Args: float lrate\n:Return: None"
    },
    "set_sid_mode": {
      "name": "set_sid_mode",
      "doc": "Set sidereal mode.",
      "full_doc": "Set sidereal mode.\n\n:Args: int sidmode, float t0=0.0, float ayan_t0=0.0\n:Return: None\n\nThis function can be used to specify the mode for sidereal computations. ``calc()`` or ``fixstar()`` has then to be called with the bit ``FLG_SIDEREAL``.\n\nIf ``set_sid_mode()`` is not called, the default ayanamsha (Fagan/Bradley) is used.\n\nIf a predefined mode is wanted, the parameter ``sidmode`` has to be set, while ``t0`` and ``ayan_t0`` are not considered, i.e. can be 0.\n\nFor information about the sidereal modes, please read the chapter on sidereal calculations in the documentation."
    },
    "set_tid_acc": {
      "name": "set_tid_acc",
      "doc": "Set value of the tidal acceleration.",
      "full_doc": "Set value of the tidal acceleration.\n\n:Args: float acc\n\n - acc: the values possible are:\n    - TIDAL_DE200\n    - TIDAL_DE403\n    - TIDAL_DE404\n    - TIDAL_DE405\n    - TIDAL_DE406\n    - TIDAL_DE421\n    - TIDAL_DE422\n    - TIDAL_DE430\n    - TIDAL_DE431\n    - TIDAL_DE441\n    - TIDAL_26\n    - TIDAL_STEPHENSON_2016\n    - TIDAL_DEFAULT (equals TIDAL_DE431)\n    - TIDAL_MOSEPH (equals TIDAL_DE404)\n    - TIDAL_SWIEPH (equals TIDAL_DEFAULT)\n    - TIDAL_JPLEPH (equals TIDAL_DEFAULT)\n\n:Return: None\n\nWith Swiss Ephemeris versions until 1.80, this function had always to be used, if a nonstandard ephemeris like DE200 or DE421 was used.\n\nSince Swiss Ephemeris version 2.00, this function is usually not needed, because the value is automatically set according to the ephemeris files selected or available. However, under certain circumstances that are described in the documentation section for ``swe_deltat()``, the user may want to control the tidal acceleration himself.\n\nOnce the function ``set_tid_acc()`` has been used, the automatic setting of tidal acceleration is blocked. In order to unblock it again, call ``set_tid_acc(TIDAL_AUTOMATIC)``."
    },
    "set_topo": {
      "name": "set_topo",
      "doc": "Set topocentric parameters.",
      "full_doc": "Set topocentric parameters.\n\n:Args: float lon, float lat, float alt=0.0\n\n - lon: geographic longitude, in degrees (eastern positive)\n - lat: geographic latitude, in degrees (northern positive)\n - alt: geographic altitude in meters above sea level\n\n:Return: None"
    },
    "sidtime": {
      "name": "sidtime",
      "doc": "Calculate sidereal time (UT).",
      "full_doc": "Calculate sidereal time (UT).\n\n:Args: float tjdut\n\n - tjdut: input time, Julian day number, Universal Time\n\n:Return: float sidtime"
    },
    "sidtime0": {
      "name": "sidtime0",
      "doc": "Calculate sidereal time, given obliquity and nutation (UT).",
      "full_doc": "Calculate sidereal time, given obliquity and nutation (UT).\n\n:Args: float tjdut, float eps, float nutation\n\n - tjdut: input time, Julian day number, Universal Time\n - eps: obliquity, in degrees\n - nutation: nutation in longitude, in degrees\n\n:Return: float sidtime"
    },
    "sol_eclipse_how": {
      "name": "sol_eclipse_how",
      "doc": "Calculate attributes of a solar eclipse for a given geographic position and time.",
      "full_doc": "Calculate attributes of a solar eclipse for a given geographic position and time.\n\n:Args: float tjdut, seq geopos, int flags=FLG_SWIEPH\n\n - tjdut: input time, Julian day number, Universal Time\n - geopos: a sequence with:\n    - geographic longitude, in degrees (eastern positive)\n    - geographic latitude, in degrees (northern positive)\n    - geographic altitude above sea level, in meters\n\n - flags: ephemeris flag, etc\n\n:Return: int retflags, (attr)\n\n - retflags: returned bit flags:\n    - 0 if no eclipse is visible at position\n    - ECL_TOTAL ECL_ANNULAR ECL_PARTIAL\n - attr: tuple of 20 float, of which:\n    - 0: fraction of solar diameter covered by moon\n    - 1: ratio of lunar diameter to solar one\n    - 2: fraction of solar disc covered by moon (obscuration)\n    - 3: diameter of core shadow in km\n    - 4: azimuth of sun at tjd\n    - 5: true altitude of sun above horizon at tjd\n    - 6: apparent altitude of sun above horizon at tjd\n    - 7: elongation of moon in degrees (separation angle)\n    - 8: magnitude acc. to NASA (equals attr[0] for partial and attr[1] for      annular and total eclipses)\n    - 9: saros series number (if available, otherwise -99999999)\n    - 10: saros series member number (if available, otherwise -99999999)\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "sol_eclipse_when_glob": {
      "name": "sol_eclipse_when_glob",
      "doc": "Find the next solar eclipse globally (UT).",
      "full_doc": "Find the next solar eclipse globally (UT).\n\n:Args: float tjdut, int flags=FLG_SWIEPH, int ecltype=0, bool backwards=False\n\n - tjdut: input time, Julian day number, Universal Time\n - flags: ephemeris flag\n - ecltype: bit flags for eclipse type wanted:\n    - ECL_CENTRAL ECL_NONCENTRAL ECL_TOTAL ECL_ANNULAR ECL_PARTIAL\n    - ECL_ANNULAR_TOTAL (equals ECL_HYBRID)\n    - ECL_ALLTYPES_SOLAR or 0 for any type\n - backwards: boolean, set to True to search back in time\n\n:Return: int res, (tret)\n\n - res: returned bit flags:\n    - ECL_TOTAL ECL_ANNULAR ECL_PARTIAL ECL_ANNULAR_TOTAL\n    - ECL_CENTRAL\n    - ECL_NONCENTRAL\n\n - tret: tuple of 10 float, of which:\n    - 0: time of maximum eclipse\n    - 1: time when eclipse takes place at local apparent noon\n    - 2: time of eclipse begin\n    - 3: time of eclipse end\n    - 4: time of totality begin\n    - 5: time of totality end\n    - 6: time of center line begin\n    - 7: time of center line end\n    - 8: time when annular-total eclipse becomes total\n    - 9: time when annular-total eclipse becomes annular again\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "sol_eclipse_when_loc": {
      "name": "sol_eclipse_when_loc",
      "doc": "Find the next solar eclipse for a given geographic position (UT).",
      "full_doc": "Find the next solar eclipse for a given geographic position (UT).\n\n:Args: float tjdut, seq geopos, int flags=FLG_SWIEPH, bool backwards=False\n\n - tjdut: input time, Julian day number, Universal Time\n - geopos: a sequence with:\n    - geographic longitude, in degrees (eastern positive)\n    - geographic latitude, in degrees (northern positive)\n    - geographic altitude above sea level, in meters\n - flags: ephemeris flag, etc\n - backwards: boolean, set to True to search back in time\n\n:Return: int retflags, (tret), (attr)\n\n - retflags: returned bit flags:\n    - ECL_TOTAL or ECL_ANNULAR or ECL_PARTIAL,\n    - ECL_VISIBLE, ECL_MAX_VISIBLE, ECL_1ST_VISIBLE, ECL_2ND_VISIBLE,\n      ECL_3RD_VISIBLE, ECL_4TH_VISIBLE\n - tret: tuple of 10 float, of which:\n    - 0: time of maximum eclipse\n    - 1: time of first contact\n    - 2: time of second contact\n    - 3: time of third contact\n    - 4: time of fourth contact\n    - 5: time of sunrise between first and fourth contact\n    - 6: time of sunset between first and fourth contact\n - attr: tuple of 20 float, of which:\n    - 0: fraction of solar diameter covered by moon; with total/annular\n      eclipse, it results in magnitude acc. to IMCCE.\n    - 1: ratio of lunar diameter to solar one\n    - 2: fraction of solar disc covered by moon (obscuration)\n    - 3: diameter of core shadow in km\n    - 4: azimuth of sun at tjd\n    - 5: true altitude of sun above horizon at tjd\n    - 6: apparent altitude of sun above horizon at tjd\n    - 7: elongation of moon in degrees (separation angle)\n    - 8: magnitude acc. to NASA (equals attr[0] for partial and attr[1] for      annular and total eclipses)\n    - 9: saros series number (if available, otherwise -99999999)\n    - 10: saros series member number (if available, otherwise -99999999)\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "sol_eclipse_where": {
      "name": "sol_eclipse_where",
      "doc": "Find where a solar eclipse is central or maximal (UT).",
      "full_doc": "Find where a solar eclipse is central or maximal (UT).\n\n:Args: float tjdut, int flags=FLG_SWIEPH\n\n - tjdut: input time, Julian day number, Universal Time\n - flags: ephemeris flag\n\n:Return: int retflags, (geopos), (attr)\n\n - retflags: returned bit flags:\n    - ECL_TOTAL\n    - ECL_ANNULAR\n    - ECL_TOTAL | ECL_CENTRAL\n    - ECL_TOTAL | ECL_NONCENTRAL\n    - ECL_ANNULAR | ECL_CENTRAL\n    - ECL_ANNULAR | ECL_NONCENTRAL\n    - ECL_PARTIAL\n - geopos: tuple of 10 float for longitude/latitude of:\n    - 0: geographic longitude of central line\n    - 1: geographic latitude of central line\n    - 2: geographic longitude of northern limit of umbra\n    - 3: geographic latitude of northern limit of umbra\n    - 4: geographic longitude of southern limit of umbra\n    - 5: geographic latitude of southern limit of umbra\n    - 6: geographic longitude of northern limit of penumbra\n    - 7: geographic latitude of northern limit of penumbra\n    - 8: geographic longitude of southern limit of penumbra\n    - 9: geographic latitude of southern limit of penumbra\n - attr: tuple of 20 float, of which:\n    - 0: fraction of solar diameter covered by moon; with total/annular\n      eclipse, it results in magnitude acc. to IMCCE.\n    - 1: ratio of lunar diameter to solar one\n    - 2: fraction of solar disc covered by moon\n    - 3: diameter of core shadow in km\n    - 4: azimuth of sun at tjd\n    - 5: true altitude of sun above horizon at tjd\n    - 6: apparent altitude of sun above horizon at tjd\n    - 7: elongation of moon in degrees (separation angle)\n    - 8: magnitude acc. to NASA (equals attr[0] for partial and attr[1] for      annular and total eclipses)\n    - 9: saros series number (if available, otherwise -99999999)\n    - 10: saros series member number (if available, otherwise -99999999)\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "solcross": {
      "name": "solcross",
      "doc": "Compute next Sun crossing over some longitude (ET).",
      "full_doc": "Compute next Sun crossing over some longitude (ET).\n\n:Args: float x2cross, float tjdet, int flags=FLG_SWIEPH\n\n - x2cross: longitude to search\n - tjdet: start time of search, Julian day number, Ephemeris Time\n - flags: bit flags indicating what computation is wanted\n\n:Return: float jdcross\n\n - jdcross: Julian day number found\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "solcross_ut": {
      "name": "solcross_ut",
      "doc": "Compute next Sun crossing over some longitude (UT).",
      "full_doc": "Compute next Sun crossing over some longitude (UT).\n\n:Args: float x2cross, float tjdut, int flags=FLG_SWIEPH\n\n - x2cross: longitude to search\n - tjdut: start time of search, Julian day number, Universal Time\n - flags: bit flags indicating what computation is wanted\n\n:Return: float jdcross\n\n - jdcross: Julian day number found\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "split_deg": {
      "name": "split_deg",
      "doc": "Provide sign or nakshatra, degree, minutes, seconds and fraction of second from decimal degree. Can also round to seconds, minutes, degrees.",
      "full_doc": "Provide sign or nakshatra, degree, minutes, seconds and fraction of second from decimal degree. Can also round to seconds, minutes, degrees.\n\n:Args: float degree, int roundflag\n\n - degree: position in decimal degrees\n - roundflag: bit flags combination indicating how to round:\n    - 0: dont round\n    - SPLIT_DEG_ROUND_SEC: round to seconds\n    - SPLIT_DEG_ROUND_MIN: round to minutes\n    - SPLIT_DEG_ROUND_DEG: round to degrees\n    - SPLIT_DEG_ZODIACAL: with zodiac sign number\n    - SPLIT_DEG_NAKSHATRA: with nakshatra number\n    - SPLIT_DEG_KEEP_SIGN: dont round to next zodiac sign/nakshatra\n    - SPLIT_DEG_KEEP_DEG: dont round to next degree\n\n:Return: deg, min, sec, secfr, sign\n\n - deg: returned degree\n - min: returned minutes\n - sec: returned seconds\n - secfr: returned fraction of second\n - sign: returned sign/nakshatra number"
    },
    "time_equ": {
      "name": "time_equ",
      "doc": "Calculate equation of time (UT).",
      "full_doc": "Calculate equation of time (UT).\n\n:Args: float tjdut\n\n - tjdut: input time, Julian day number, Universal Time\n\n:Return: float e\n\n - e: difference between local apparent time and local mean time in days\n\nThis function raises swisseph.Error in case of fatal error."
    },
    "utc_time_zone": {
      "name": "utc_time_zone",
      "doc": "Transform local time to UTC or UTC to local time.",
      "full_doc": "Transform local time to UTC or UTC to local time.\n\n:Args: int year, int month, int day, int hour, int minutes, float seconds, float offset\n\n - year, month, day, hour, minutes, seconds: date and time\n - offset: timezone offset in hours (east of greenwich positive)\n\n:Return: int retyear, retmonth, retday, rethour, retmin, float retsec\n\n - retyear, retmonth, retday: returned date\n - rethour, retmin, retsec: returned time\n\nFor conversion from local time to UTC, use +(offset). For conversion from UTC to local time, use -(offset)."
    },
    "utc_to_jd": {
      "name": "utc_to_jd",
      "doc": "Convert UTC to julian day.",
      "full_doc": "Convert UTC to julian day.\n\n:Args: int year, int month, int day, int hour, int minutes, float seconds, int cal=GREG_CAL\n\n - year, month, day, hour, minutes, seconds: date and time\n - cal: either GREG_CAL or JUL_CAL\n\n:Return: float jdet, float jdut\n\n - jdet: Julian day in ET (TT)\n - jdut: Julian day in UT (UT1)\n\nThis function raises ValueError if cal is not GREG_CAL or JUL_CAL.\nIt raises swisseph.Error in case of fatal error."
    },
    "vis_limit_mag": {
      "name": "vis_limit_mag",
      "doc": "Find the limiting visual magnitude in dark skies.",
      "full_doc": "Find the limiting visual magnitude in dark skies.\n\n:Args: float tjdut, seq geopos, seq atmo, seq observer, str objname, int flags\n\n - tjdut: input time, Julian day number, Universal Time\n - geopos: a sequence with:\n    - 0: geographic longitude (eastern positive)\n    - 1: geographic latitude (northern positive)\n    - 2: altitude above sea level, in meters\n - atmo: a sequence with:\n    - 0: atmospheric pressure in mbar (hPa)\n    - 1: atmospheric temperature in degrees Celsius\n    - 2: relative humidity in %\n    - 3: if >= 1, Meteorological Range (km).\n      Between 1 and 0, total atmospheric coefficient (ktot).\n      If = 0, the other atmospheric parameters determine the total\n      atmospheric coefficient (ktot)\n - observer: a sequence with:\n    - 0: age of observer in years (default = 36)\n    - 1: snellen ratio of observers eyes (default = 1 = normal)\n    - The following parameters are only relevant if HELFLAG_OPTICAL_PARAMS\n      is set:\n    - 2: (0) = monocular, (1) = binocular (boolean)\n    - 3: telescope magnification, (0) = default to naked eye (binocular),\n      (1) = naked eye\n    - 4: optical aperture (telescope diameter) in mm\n    - 5: optical transmission\n - objname: name of planet or fixed star\n - flags: bit flags for ephemeris, and also:\n    - HELFLAG_OPTICAL_PARAMS: for optical instruments\n    - HELFLAG_NO_DETAILS: provide date, without details\n    - HELFLAG_VISLIM_DARK: behave as if Sun is at nadir\n    - HELFLAG_VISLIM_NOMOON: behave as if Moon is at nadir, i.e. the Moon as\n      a factor disturbing the observation is excluded, useful if one is not\n      interested in the heliacal date of that particular year, but in the\n      heliacal date of that epoch\n\n:Return: float res, (dret)\n\n - res: result:\n    - (-2): object is below horizon\n    - (0): OK, photopic vision\n    - (1): OK, scotopic vision\n    - (2): OK, near limit photopic/scotopic vision\n - dret: a tuple of 10 float, of which:\n    - 0: limiting visual magnitude (if > magnitude of object, then the\n      object is visible)\n    - 1: altitude of object\n    - 2: azimuth of object\n    - 3: altitude of sun\n    - 4: azimuth of sun\n    - 5: altitude of moon\n    - 6: azimuth of moon\n    - 7: magnitude of object\n\nThis function raises swisseph.Error in case of fatal error."
    }
  },
  "others": [
    "ASTNAMFILE",
    "AUNIT_TO_KM",
    "AUNIT_TO_LIGHTYEAR",
    "AUNIT_TO_PARSEC",
    "DELTAT_AUTOMATIC",
    "EPHE_PATH",
    "FICTFILE",
    "FNAME_DE200",
    "FNAME_DE403",
    "FNAME_DE404",
    "FNAME_DE405",
    "FNAME_DE406",
    "FNAME_DFT",
    "FNAME_DFT2",
    "SE_FNAME_DE431",
    "STARFILE",
    "STARFILE_OLD",
    "TIDAL_26",
    "TIDAL_DE200",
    "TIDAL_DE403",
    "TIDAL_DE404",
    "TIDAL_DE405",
    "TIDAL_DE406",
    "TIDAL_DE421",
    "TIDAL_DE422",
    "TIDAL_DE430",
    "TIDAL_DE431",
    "TIDAL_DE441",
    "TIDAL_DEFAULT",
    "TIDAL_JPLEPH",
    "TIDAL_MOSEPH",
    "TIDAL_STEPHENSON_2016",
    "TIDAL_SWIEPH",
    "TJD_INVALID",
    "contrib",
    "version"
  ]
}