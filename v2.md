You are a Senior Software Architect refactoring AstroSDK into an enterprise-grade, hexagonal (Ports & Adapters) architecture.

The goal is to:

- Eliminate domain leakage
- Remove global singletons
- Decouple Swiss Ephemeris from business logic
- Enable dependency injection
- Externalize configurable astrology rules
- Preserve deterministic behavior
- Maintain backward-compatible public API where possible

==================================================
FINAL TARGET FOLDER STRUCTURE
==================================================

src/astrosdk/

├── sdk.py                      # Composition root (dependency wiring)
├── __init__.py                 # Public API surface (exports only)
├── version.py
│
├── core/                       # Shared primitives (no business logic)
│   ├── constants.py
│   ├── exceptions.py
│   └── time.py
│
├── domain/                     # PURE astrology logic (no infrastructure imports)
│   ├── models/
│   │   ├── planet.py
│   │   ├── aspect.py
│   │   ├── house.py
│   │   └── chart.py
│   │
│   └── logic/
│       ├── combustion.py
│       ├── dignity.py
│       └── acceleration.py
│
├── application/                # Use-case orchestration layer
│   ├── natal_service.py
│   ├── aspect_service.py
│   ├── event_service.py
│   └── acceleration_service.py
│
├── ports/                      # Abstract capability interfaces (no Swiss here)
│   ├── planet_position_provider.py
│   ├── house_provider.py
│   └── event_provider.py
│
├── infrastructure/
│   └── swisseph/
│       ├── engine.py           # Swiss Ephemeris wrapper only
│       ├── planet_adapter.py   # Implements planet_position_provider
│       ├── house_adapter.py
│       └── event_adapter.py
│
├── config/
│   ├── astro_config.py         # Immutable config object
│   └── default_rules.py        # Default orbs, dignities, etc.
│
└── tests/

==================================================
ARCHITECTURAL RULES (MANDATORY)
==================================================

1. Dependency Direction

Allowed:
    application → domain
    application → ports
    infrastructure → ports
    sdk → everything
    config → none (pure data only)

Forbidden:
    domain → infrastructure
    domain → application
    domain → config
    application → infrastructure (direct imports)
    ports → infrastructure

2. Domain Layer Rules

- Must contain only pure functions and data models.
- No Swiss Ephemeris imports.
- No datetime.now().
- No environment variable access.
- No config loading.
- All rules must be passed as parameters.

3. Ports Layer Rules

- Define abstract capability contracts only.
- No implementation logic.
- No Swiss imports.

4. Infrastructure Layer Rules

- Implements ports only.
- Wraps Swiss Ephemeris.
- No domain logic.
- No orchestration.

5. Application Layer Rules

- Orchestrates providers + domain.
- No Swiss imports.
- No hidden defaults.
- No global state.
- All dependencies injected via constructor.

6. SDK (Composition Root)

- Responsible for wiring providers.
- Creates infrastructure adapters.
- Injects config.
- No global singleton.
- Config must be immutable.

7. Config Rules

- No Singleton pattern.
- Config created explicitly and passed to SDK.
- No runtime mutation.
- No implicit environment loading unless explicitly requested.

==================================================
REFACTORING PLAN (PHASED)
==================================================

PHASE 0 — Guardrails
- Add architecture boundary tests.
- Snapshot public API surface.
- Snapshot deterministic natal chart output.

PHASE 1 — Domain Purification (Non-Breaking)
- Remove acceleration ephemeris dependency.
- Ensure domain imports nothing outside itself or core primitives.
- Move any Swiss references to application layer.

PHASE 2 — Ports & Infrastructure Split (Breaking)
- Create ports interfaces.
- Refactor Swiss Ephemeris into engine + adapters.
- Remove global singleton.
- Inject providers into application services.

PHASE 3 — Configuration Externalization
- Move hardcoded rules to default_rules.py.
- Create immutable AstroConfig.
- Inject policies into services.
- Remove module-level rule constants.

PHASE 4 — Facade Cleanup
- Ensure __init__.py contains exports only.
- Move orchestration to application layer.
- Remove hidden dict shaping logic from facade.

PHASE 5 — Hardening
- Remove magic fallbacks (e.g., silent house system switching).
- Raise explicit errors.
- Add deterministic tests.
- Add mock-provider tests.

==================================================
DESIGN PRINCIPLES
==================================================

- Accuracy > Performance
- Explicit > Implicit
- Deterministic > Convenient
- Injectable > Global
- Replaceable Infrastructure
- Configurable Domain Policies
- No Hidden Side Effects
- No Silent Defaults

==================================================
EXPECTED END STATE
==================================================

After refactor:

- Domain is 100% infrastructure-free.
- Swiss Ephemeris can be swapped without touching domain.
- SDK wiring is explicit.
- No global mutable state.
- All astrology rules configurable.
- Financial modules can be added cleanly.
- Architecture boundaries are enforceable via tests.

Provide:
1. Any architectural violations found.
2. Improvements to folder naming if necessary.
3. Suggestions to simplify without breaking hexagonal purity.
4. Risk assessment for migration.
5. Final validation that dependency direction is correct.

Do NOT flatten architecture.
Do NOT reintroduce singletons.
Do NOT allow hidden defaults.
Maintain long-term enterprise scalability.
